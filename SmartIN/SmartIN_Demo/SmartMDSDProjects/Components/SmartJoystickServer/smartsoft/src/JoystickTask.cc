//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

// --------------------------------------------------------------------------
//
//  Copyright (C) 2003 Boris Kluge
//
//        schlegel@hs-ulm.de
//
//        Prof. Dr. Christian Schlegel
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This program is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this program; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------
#include "JoystickTask.hh"
#include "SmartJoystickServer.hh"

#include <cstdio>
#include <cstring>
#include <iostream>

JoystickTask::JoystickTask(SmartACE::SmartComponent *comp)
:	JoystickTaskCore(comp, false)
{
	std::cout << "constructor JoystickTask\n";
	data_changed = true;
	select_status = 0;
}
JoystickTask::~JoystickTask() 
{
	std::cout << "destructor JoystickTask\n";
}

int JoystickTask::getPreviousCommObjId()
{
	return 0;
}

int JoystickTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further

	// try to open joystick device
	js_fd = ::open(COMP->getGlobalState().getGeneral().getDevice().c_str(), O_RDONLY);
	if(js_fd<0)
	{
		std::cerr << "ERROR: failed to open \"" << COMP->getGlobalState().getGeneral().getDevice() << "\" as joystick device." << std::endl;
		std::cerr << strerror(errno) << std::endl;
		return -1;
	}
	else if(COMP->getGlobalState().getGeneral().getVerbose())
	{
		if (ioctl(js_fd, JSIOCGNAME(BUFFER_SIZE), buffer) < 0)
		{
			strncpy(buffer, "<unknown>", BUFFER_SIZE);
		}
		std::cout << "Connected to \"" << buffer << "\"." << std::endl;
	}

	return 0;
}

int JoystickTask::on_execute()
{
	fd_set js_fd_set;
	timeval timeout;
	int select_status;

	FD_ZERO(&js_fd_set);
	FD_SET(js_fd, &js_fd_set);

	if(data_changed)
	{
		timeout.tv_sec  =  int(::floor(COMP->getGlobalState().getGeneral().getInterval_min()));
		timeout.tv_usec = (int(::floor(COMP->getGlobalState().getGeneral().getInterval_min() * 1000000)) % 1000000);
	}
	else
	{
		timeout.tv_sec  =  int(::floor(COMP->getGlobalState().getGeneral().getInterval_max()));
		timeout.tv_usec = (int(::floor(COMP->getGlobalState().getGeneral().getInterval_max() * 1000000)) % 1000000);
	}

	select_status = select(js_fd + 1, &js_fd_set, 0, 0, &timeout);

	if(select_status>0)
	{
		int bytes_read = ::read(js_fd, js_data, DATA_SIZE * sizeof(js_event));
		if(bytes_read>0)
		{
			unsigned int num_events_read = bytes_read / sizeof(js_event);
			for(unsigned int i=0; i<num_events_read; ++i)
			{
				if(js_data[i].type & JS_EVENT_BUTTON)
				{
					if(js_data[i].number < 8)
					{
						js.set_button(js_data[i].number, bool(js_data[i].value));
					}
				}
				else if(js_data[i].type & JS_EVENT_AXIS)
				{
					if(js_data[i].number==0)        //left joystick (joystick 1)
					{
						//js.set_x_int(js_data[i].value);
						if(COMP->getGlobalState().getGeneral().getInvert_x1_axis())
						{
							js.set_x_int(-js_data[i].value);
						}
						else
						{
							js.set_x_int(js_data[i].value);
						}
					}
					else if(js_data[i].number==1)   //left joystick (joystick 1)
					{
						if(COMP->getGlobalState().getGeneral().getInvert_y1_axis())
						{
							js.set_y_int(-js_data[i].value);
						}
						else
						{
							js.set_y_int(js_data[i].value);
						}
					}
					else if(js_data[i].number==2)     //right joytsick (joystick 2)
					{
						//js.set_x2_int(js_data[i].value);
						if(COMP->getGlobalState().getGeneral().getInvert_x2_axis())
						{
								js.set_x2_int(-js_data[i].value);
						}
						else
						{
								js.set_x2_int(js_data[i].value);
						}
					}
					else if(js_data[i].number==3)     //right joystick (joystick 2)
					{
						if(COMP->getGlobalState().getGeneral().getInvert_y2_axis())
						{
								js.set_y2_int(-js_data[i].value);
						}
						else
						{
								js.set_y2_int(js_data[i].value);
						}
					}

				}
			}
			data_changed = true;
		}
	}
	else
	{
		if(select_status<0)
		{
			std::cerr << "WARNING: select failed." << std::endl;
		}
	}

	now.set_now();
	if(now.seconds_after(last_push_time) >= COMP->getGlobalState().getGeneral().getInterval_min())
	{
		last_push_time = now;
		data_changed = false;
		status = this->joystickServcieOutPut(js);
		if(status!=Smart::SMART_OK)
		{
			std::cerr << "WARNING: error on push (" << status << ")" << std::endl;
		}
		else
		{
			data_changed = false;
			if(COMP->getGlobalState().getGeneral().getVerbose()) std::cout << js << " sent." << std::endl;
		}
	}

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int JoystickTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
