//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "JoystickManTask.hh"
#include "SmartINJoystickManager.hh"

#include <iostream>

JoystickManTask::JoystickManTask(SmartACE::SmartComponent *comp) 
:	JoystickManTaskCore(comp)
{
	std::cout << "constructor JoystickManTask\n";
}
JoystickManTask::~JoystickManTask() 
{
	std::cout << "destructor JoystickManTask\n";
}


void JoystickManTask::on_JoystickServiceIn_1(const CommBasicObjects::CommJoystick &input)
{
	// upcall triggered from InputPort JoystickServiceIn_1
	// - use a local mutex here, because this upcal is called asynchroneously from outside of this task
	// - do not use longer blocking calls here since this upcall blocks the InputPort JoystickServiceIn_1
	// - if you need to implement a long-running procedure, do so within the on_execute() method and in
	//   there, use the method joystickServiceIn_1GetUpdate(input) to get a copy of the input object
}
void JoystickManTask::on_JoystickServiceIn_2(const CommBasicObjects::CommJoystick &input)
{
	// upcall triggered from InputPort JoystickServiceIn_2
	// - use a local mutex here, because this upcal is called asynchroneously from outside of this task
	// - do not use longer blocking calls here since this upcall blocks the InputPort JoystickServiceIn_2
	// - if you need to implement a long-running procedure, do so within the on_execute() method and in
	//   there, use the method joystickServiceIn_2GetUpdate(input) to get a copy of the input object
}
void JoystickManTask::on_JoystickServiceIn_3(const CommBasicObjects::CommJoystick &input)
{
	// upcall triggered from InputPort JoystickServiceIn_3
	// - use a local mutex here, because this upcal is called asynchroneously from outside of this task
	// - do not use longer blocking calls here since this upcall blocks the InputPort JoystickServiceIn_3
	// - if you need to implement a long-running procedure, do so within the on_execute() method and in
	//   there, use the method joystickServiceIn_3GetUpdate(input) to get a copy of the input object
}
void JoystickManTask::on_JoystickServiceIn_4(const CommBasicObjects::CommJoystick &input)
{
	// upcall triggered from InputPort JoystickServiceIn_4
	// - use a local mutex here, because this upcal is called asynchroneously from outside of this task
	// - do not use longer blocking calls here since this upcall blocks the InputPort JoystickServiceIn_4
	// - if you need to implement a long-running procedure, do so within the on_execute() method and in
	//   there, use the method joystickServiceIn_4GetUpdate(input) to get a copy of the input object
}
void JoystickManTask::on_JoystickServiceIn_5(const CommBasicObjects::CommJoystick &input)
{
	// upcall triggered from InputPort JoystickServiceIn_5
	// - use a local mutex here, because this upcal is called asynchroneously from outside of this task
	// - do not use longer blocking calls here since this upcall blocks the InputPort JoystickServiceIn_5
	// - if you need to implement a long-running procedure, do so within the on_execute() method and in
	//   there, use the method joystickServiceIn_5GetUpdate(input) to get a copy of the input object
}

int JoystickManTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	return 0;
}

bool isequal(CommBasicObjects::CommJoystick A, CommBasicObjects::CommJoystick B){
	if (A.get_x() != A.get_x())
		return false;
	if (A.get_x2() != B.get_x2())
		return false;
	if (A.get_y() != B.get_y())
		return false;
	if (A.get_y2() != B.get_y2())
		return false;
	if (A.getButtons() != B.getButtons())
		return false;
	return true;
}

int JoystickManTask::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel
	
	CommBasicObjects::CommJoystick joystickServiceIn_Zeros;
	joystickServiceIn_Zeros.set_x(0);
	joystickServiceIn_Zeros.set_x2(0);
	joystickServiceIn_Zeros.set_y(0);
	joystickServiceIn_Zeros.set_y2(0);
	joystickServiceIn_Zeros.setButtons(0);
	std::cout << "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n" << std::endl;
	std::cout << "===================================================================" << std::endl;
	std::cout << "===================================================================" << joystickServiceIn_Zeros << std::endl;
	std::cout << "===================================================================" << std::endl;
	CommBasicObjects::CommJoystick joystickServiceIn_Use;

	Smart::StatusCode status;
	CommBasicObjects::CommJoystick joystickServiceIn_1Object;
	CommBasicObjects::CommJoystick joystickServiceIn_2Object;
	CommBasicObjects::CommJoystick joystickServiceIn_3Object;
	CommBasicObjects::CommJoystick joystickServiceIn_4Object;
	CommBasicObjects::CommJoystick joystickServiceIn_5Object;
	// to get the incoming data, use this methods:

	status = this->joystickServiceIn_1GetUpdate(joystickServiceIn_1Object);
	if(status != Smart::SMART_OK) {
		std::cerr << status << std::endl;
	} else {
		std::cout << "received from 1: " << joystickServiceIn_1Object << std::endl;
	}
	status = this->joystickServiceIn_2GetUpdate(joystickServiceIn_2Object);
	if(status != Smart::SMART_OK) {
		std::cerr << status << std::endl;
	} else {
		std::cout << "received from 2: " << joystickServiceIn_2Object << std::endl;
	}
	status = this->joystickServiceIn_3GetUpdate(joystickServiceIn_3Object);
	if(status != Smart::SMART_OK) {
		std::cerr << status << std::endl;
	} else {
		std::cout << "received from 3: " << joystickServiceIn_3Object << std::endl;
	}
	status = this->joystickServiceIn_4GetUpdate(joystickServiceIn_4Object);
	if(status != Smart::SMART_OK) {
		std::cerr << status << std::endl;
	} else {
		std::cout << "received from 4: " << joystickServiceIn_4Object << std::endl;
	}
	status = this->joystickServiceIn_5GetUpdate(joystickServiceIn_5Object);
	if(status != Smart::SMART_OK) {
		std::cerr << status << std::endl;
	} else {
		std::cout << "received from 5: " << joystickServiceIn_5Object << std::endl;
	}

	std::string selectedport = "NA";
	if(!isequal(joystickServiceIn_1Object, joystickServiceIn_Zeros))	{
		joystickServiceIn_Use = joystickServiceIn_1Object;
		selectedport = "[1]";
	} else{
		if(!isequal(joystickServiceIn_2Object, joystickServiceIn_Zeros))	{
			joystickServiceIn_Use = joystickServiceIn_2Object;
			selectedport = "[2]";
		} else{
			if(!isequal(joystickServiceIn_3Object, joystickServiceIn_Zeros))	{
				joystickServiceIn_Use = joystickServiceIn_3Object;
				selectedport = "[3]";
			} else{
				if(!isequal(joystickServiceIn_4Object, joystickServiceIn_Zeros))	{
					joystickServiceIn_Use = joystickServiceIn_4Object;
					selectedport = "[4]";
				} else{
					if(!isequal(joystickServiceIn_5Object, joystickServiceIn_Zeros))	{
						joystickServiceIn_Use = joystickServiceIn_5Object;
						selectedport = "[5]";
					} else{
						joystickServiceIn_Use = joystickServiceIn_Zeros;
						selectedport = "[NA]";
					}
				}
			}
		}
	}


	status = this->joystickServiceOutPut(joystickServiceIn_Use);
	if ( status != Smart::SMART_OK ) {
		std::cerr << "ERROR: failed to send velocity ("	<< status << ")" << std::endl;
	} else {
		std::cout << selectedport << "=Port=>"  << joystickServiceIn_Use << " sent." << std::endl;
	}

	std::cout << "Hello from JoystickManTask " << std::endl;

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int JoystickManTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
